// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tokens.sql

package sqlcrepo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createToken = `-- name: CreateToken :one
INSERT INTO tokens (
  id, user_id,active,value,expires, created_at, created_by,updated_at,updated_by
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8,$9
)
RETURNING id
`

type CreateTokenParams struct {
	ID        string
	UserID    string
	Active    int32
	Value     string
	Expires   pgtype.Timestamp
	CreatedAt pgtype.Timestamp
	CreatedBy string
	UpdatedAt pgtype.Timestamp
	UpdatedBy string
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) (string, error) {
	row := q.db.QueryRow(ctx, createToken,
		arg.ID,
		arg.UserID,
		arg.Active,
		arg.Value,
		arg.Expires,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteTokenByValue = `-- name: DeleteTokenByValue :exec
DELETE FROM tokens
WHERE value = $1
`

func (q *Queries) DeleteTokenByValue(ctx context.Context, value string) error {
	_, err := q.db.Exec(ctx, deleteTokenByValue, value)
	return err
}

const getToken = `-- name: GetToken :one
SELECT tokens.id, tokens.value, tokens.active, tokens.expires, tokens.created_at, tokens.created_by, tokens.updated_at, tokens.updated_by, tokens.user_id, users.username FROM tokens
JOIN users on tokens.user_id = users.id
WHERE tokens.id = $1 LIMIT 1
`

type GetTokenRow struct {
	ID        string
	Value     string
	Active    int32
	Expires   pgtype.Timestamp
	CreatedAt pgtype.Timestamp
	CreatedBy string
	UpdatedAt pgtype.Timestamp
	UpdatedBy string
	UserID    string
	Username  string
}

func (q *Queries) GetToken(ctx context.Context, id string) (GetTokenRow, error) {
	row := q.db.QueryRow(ctx, getToken, id)
	var i GetTokenRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Active,
		&i.Expires,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.UserID,
		&i.Username,
	)
	return i, err
}

const getTokenByValue = `-- name: GetTokenByValue :one
SELECT tokens.id, tokens.value, tokens.active, tokens.expires, tokens.created_at, tokens.created_by, tokens.updated_at, tokens.updated_by, tokens.user_id,users.username FROM tokens
JOIN users on tokens.user_id = users.id
WHERE value = $1 LIMIT 1
`

type GetTokenByValueRow struct {
	ID        string
	Value     string
	Active    int32
	Expires   pgtype.Timestamp
	CreatedAt pgtype.Timestamp
	CreatedBy string
	UpdatedAt pgtype.Timestamp
	UpdatedBy string
	UserID    string
	Username  string
}

func (q *Queries) GetTokenByValue(ctx context.Context, value string) (GetTokenByValueRow, error) {
	row := q.db.QueryRow(ctx, getTokenByValue, value)
	var i GetTokenByValueRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Active,
		&i.Expires,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.UserID,
		&i.Username,
	)
	return i, err
}

const listTokens = `-- name: ListTokens :many
SELECT tokens.id, tokens.value, tokens.active, tokens.expires, tokens.created_at, tokens.created_by, tokens.updated_at, tokens.updated_by, tokens.user_id,users.username FROM tokens
JOIN users on tokens.user_id = users.id
ORDER BY tokens.id
`

type ListTokensRow struct {
	ID        string
	Value     string
	Active    int32
	Expires   pgtype.Timestamp
	CreatedAt pgtype.Timestamp
	CreatedBy string
	UpdatedAt pgtype.Timestamp
	UpdatedBy string
	UserID    string
	Username  string
}

func (q *Queries) ListTokens(ctx context.Context) ([]ListTokensRow, error) {
	rows, err := q.db.Query(ctx, listTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTokensRow
	for rows.Next() {
		var i ListTokensRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.Active,
			&i.Expires,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.UserID,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTokens = `-- name: ListUserTokens :many
SELECT tokens.id, tokens.value, tokens.active, tokens.expires, tokens.created_at, tokens.created_by, tokens.updated_at, tokens.updated_by, tokens.user_id,users.username FROM tokens
JOIN users on tokens.user_id = users.id
WHERE user_id = $1
ORDER BY tokens.id
`

type ListUserTokensRow struct {
	ID        string
	Value     string
	Active    int32
	Expires   pgtype.Timestamp
	CreatedAt pgtype.Timestamp
	CreatedBy string
	UpdatedAt pgtype.Timestamp
	UpdatedBy string
	UserID    string
	Username  string
}

func (q *Queries) ListUserTokens(ctx context.Context, userID string) ([]ListUserTokensRow, error) {
	rows, err := q.db.Query(ctx, listUserTokens, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserTokensRow
	for rows.Next() {
		var i ListUserTokensRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.Active,
			&i.Expires,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.UserID,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTokensByName = `-- name: ListUserTokensByName :many
SELECT tokens.id, tokens.value, tokens.active, tokens.expires, tokens.created_at, tokens.created_by, tokens.updated_at, tokens.updated_by, tokens.user_id,users.username FROM tokens
JOIN users on tokens.user_id = users.id
WHERE users.username = $1
ORDER BY tokens.id
`

type ListUserTokensByNameRow struct {
	ID        string
	Value     string
	Active    int32
	Expires   pgtype.Timestamp
	CreatedAt pgtype.Timestamp
	CreatedBy string
	UpdatedAt pgtype.Timestamp
	UpdatedBy string
	UserID    string
	Username  string
}

func (q *Queries) ListUserTokensByName(ctx context.Context, username string) ([]ListUserTokensByNameRow, error) {
	rows, err := q.db.Query(ctx, listUserTokensByName, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserTokensByNameRow
	for rows.Next() {
		var i ListUserTokensByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.Active,
			&i.Expires,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.UserID,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTokenValidity = `-- name: UpdateTokenValidity :one
UPDATE tokens
  set active = $2,
  updated_at = $3,
  updated_by = $4
WHERE id = $1
RETURNING id, value, active, expires, created_at, created_by, updated_at, updated_by, user_id
`

type UpdateTokenValidityParams struct {
	ID        string
	Active    int32
	UpdatedAt pgtype.Timestamp
	UpdatedBy string
}

func (q *Queries) UpdateTokenValidity(ctx context.Context, arg UpdateTokenValidityParams) (Token, error) {
	row := q.db.QueryRow(ctx, updateTokenValidity,
		arg.ID,
		arg.Active,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Active,
		&i.Expires,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.UserID,
	)
	return i, err
}
